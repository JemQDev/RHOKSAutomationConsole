// <auto-generated> This file has been auto generated by EF Core Power Tools. </auto-generated>
#nullable disable
using System;
using System.Collections.Generic;

namespace RHOKSAutomationConsole.EFACQ;

/// <summary>
/// Details the field attributes, including precision, storage, or custom attribute details.
/// </summary>
public partial class FieldAttribute
{
    /// <summary>
    /// The auto incrementing integer primary key.
    /// </summary>
    public int FieldAttributeId { get; set; }

    /// <summary>
    /// The Name of the Attribute.
    /// </summary>
    public string Name { get; set; }

    /// <summary>
    /// The Type of Field Attribute, such as precision.
    /// </summary>
    public string FieldAttributeType { get; set; }

    /// <summary>
    /// The Precision for numeric storage fields.
    /// </summary>
    public int? NumericStoragePrecision { get; set; }

    /// <summary>
    /// The Scale for numeric storage fields.
    /// </summary>
    public int? NumericStorageScale { get; set; }

    /// <summary>
    /// The Precision of a date field.
    /// </summary>
    public string DateStoragePrecision { get; set; }

    /// <summary>
    /// If type is &quot;Unit&quot;, this is the unit of measure. This can later link to a table detailing the unit (and related tables detailing conversions, etc), but as there is no such functionality in 4.x at present anyway, this will just stay null until required.
    /// </summary>
    public int? UnitId { get; set; }

    /// <summary>
    /// If type is &quot;Custom&quot;, this is the xml explaining the custom attribute details. This may include the definition of an expression which defines the value of the attribute based on the value of the field.
    /// </summary>
    public string CustomAttributeDetails { get; set; }

    /// <summary>
    /// If type is &quot;Constraint&quot;, this is the xml detailing the expression which defines the constraint.
    /// </summary>
    public string ConstraintCondition { get; set; }

    /// <summary>
    /// This is optional, and is included such that a field attribute can be made up of many other field attributes additively.
    /// </summary>
    public int? ParentFieldAttributeId { get; set; }

    /// <summary>
    /// If type is &quot;Custom&quot;, this is the related type information for this custom attribute.
    /// </summary>
    public int? CustomFieldAttributeTypeId { get; set; }

    /// <summary>
    /// The data source which the details of this record were primarily obtained from.
    /// </summary>
    public short DataSourceId { get; set; }

    public virtual AdmDateRange AdmDateRange { get; set; }

    public virtual AdmValueRange AdmValueRange { get; set; }

    public virtual CustomFieldAttributeType CustomFieldAttributeType { get; set; }

    public virtual ICollection<FieldAttribute> InverseParentFieldAttribute { get; set; } = new List<FieldAttribute>();

    public virtual FieldAttribute ParentFieldAttribute { get; set; }

    public virtual Unit Unit { get; set; }

    public virtual ICollection<CompoundField> CompoundField { get; set; } = new List<CompoundField>();

    public virtual ICollection<FieldType> FieldType { get; set; } = new List<FieldType>();
}